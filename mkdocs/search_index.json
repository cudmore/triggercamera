{
    "docs": [
        {
            "location": "/", 
            "text": "Trigger Camera\n\n\nThis is documentation to construct a system with a Raspberry Pi computer that responds to general purpose digital input-output (GPIO) pulses to start and stop video acquisition during an experiment. External events such as frame times on a scanning microscope are watermarked on the video and saved to a text file. The camera can be controlled from a Python command prompt or with a web browser.\n\n\n\n\n\n\nFigure 1. Web-browser interface.\n\n\nExample web interface for the Trigger Camera. See \nweb help\n for more information\n\n\n\n\nOverview\n\n\nThis Raspberry Pi Trigger Camera camera is designed to integrate into our \nTreadmill\n system. The Treadmill system is advantageous if an Arduino is needed to precisely control other pieces of equipment like LEDs, motors, or valves.\n\n\nThe Raspberry Pi\n\n\nThe Raspberry Pi is a low cost ($35) computer that runs Linux. In addition to USB, ethernet, and HDMI connectors, the Raspberry Pi has a dedicated camera port and GPIO ports. Both the camera and GPIO ports can be easily programmed using Python. The Raspberry Pi provides an end-to-end open source system. Both the hardware and the software is provided by \nThe Raspberry Pi Foundation\n and is actively maintained and extended by an active developer community.\n\n\nSoftware implementation\n\n\nThe software provided here will run a Raspberry Pi camera as a slave to other devices already in place for an experiment. Once the camera is armed, it will continuously record a circular stream of video in memory. When a digital trigger is received, the video will begin being saved to disk. In addition to saving the video after a trigger, the video before the trigger will also be saved. This has the distinct advantage of given you a record of what your animal was doing  before a trial was started. In many cases, 'bad trials' can be found because there was a lot of movement (or some other abberent event) before a trial began.\n\n\nVideo resolutions and FPS\n\n\nThe Raspberry Pi camera has the following resolutions and FPS. Set the resolution and FPS in the \nconfig.ini\n file. See the \nPiCamera Python documentation\n for more information.\n\n\n\n\n\n\n\n\n\n\nResolution\n\n\nAspect Ratio\n\n\nFramerates\n\n\nVideo\n\n\nImage\n\n\nFoV\n\n\nBinning\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1920x1080\n\n\n16:9\n\n\n1-30fps\n\n\nx\n\n\n\n\nPartial\n\n\nNone\n\n\n\n\n\n\n2\n\n\n2592x1944\n\n\n4:3\n\n\n1-15fps\n\n\nx\n\n\nx\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n3\n\n\n2592x1944\n\n\n4:3\n\n\n0.1666-1fps\n\n\nx\n\n\nx\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n4\n\n\n1296x972\n\n\n4:3\n\n\n1-42fps\n\n\nx\n\n\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n5\n\n\n1296x730\n\n\n16:9\n\n\n1-49fps\n\n\nx\n\n\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n6\n\n\n640x480\n\n\n4:3\n\n\n42.1-60fps\n\n\nx\n\n\n\n\nFull\n\n\n4x4\n\n\n\n\n\n\n7\n\n\n640x480\n\n\n4:3\n\n\n60.1-90fps\n\n\nx\n\n\n\n\nFull\n\n\n4x4\n\n\n\n\n\n\n\n\nLimitations\n\n\nThe Raspberry Pi runs Linux and like other operating systems including Microsoft Windows and Mac OS it is not real time. There will always be unpredictable delays in the detection and generation of GPIO pulses. If the detection of a fast pulse or the timing of a pulse is critical for an experiment it is strongly suggested to use a more precise microcontroller like an Arduino.\n\n\nThe Raspberry Pi camera is not a high-end camera. It records compressed video files, it does not record single frames to a video file. If you require a camera that captures individual frames, you should buy a high-end camera. \n\n\n\n\nSaved video files are compressed with .h264\n\n\nSaved video files are split into two files (we will wrote code to combine them after a trial)\n\n\nSome frames will be late\n\n\nSome frames may be missed\n\n\nIt is difficult to predict which frames will be late and/or missed\n\n\n\n\nSee the \nAnalysis\n section for example Python code to test the limits of this precision.\n\n\n\n\n\nParts list\n\n\nThe total cost should be about $150. These parts are widely available at many different online sellers including: Sparkfun, Adafruit, Element14, and Amazon.\n\n\n\n\n\n\n\n\nQuatity\n\n\nItem\n\n\nNote\n\n\nCost\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n1\n\n\nRaspberry Pi 2 or 3\n\n\nEither 2 or 3 is fine\n\n\n$35-$40\n\n\nelement14\nadafruit\n\n\n\n\n\n\n1\n\n\nClass 10 micro SD card\n\n\nFor the Rasperry system, 16 GB is fine\n\n\n$10\n\n\nlink\n\n\n\n\n\n\n1\n\n\n5V 2A AC to DC power\n\n\nMake sure it is \n2A and don't buy a cheap one\n\n\n$6-$8\n\n\nlink\n\n\n\n\n\n\n1\n\n\nPi NoIR Camera\n\n\n\n\n$25-$30\n\n\nlink\n\n\n\n\n\n\n1\n\n\nPi Camera Ribbon cable (2 meters)\n\n\n\n\n$6\n\n\nlink\n\n\n\n\n\n\n1\n\n\nPi Camera HDMI extension cable\n\n\nOptional\n\n\n$15\n\n\nlink\n\n\n\n\n\n\n1\n\n\nUSB Memory\n\n\nTo save video, 32GB or 64GB is a good starting point\n\n\n$10-$15\n\n\nlink\n\n\n\n\n\n\n1\n\n\nVoltage level shifter\n\n\nTo convert 5V GPIO to 3.5V\n\n\n$4\n\n\nlink\n\n\n\n\n\n\n4\n\n\nIR LEDS\n\n\n900nm is best\n\n\n$0.95\n\n\n850nm\n/\n950nm\n\n\n\n\n\n\n4\n\n\nResistors\n\n\nOne for each IR LED\n\n\n$7 (for 500 pack)\n\n\nlink\n\n\n\n\n\n\n1\n\n\n5V relay\n\n\nTo turn higher voltages like 12V on and off\n\n\n$3\n\n\nlink\n\n\n\n\n\n\n\n\nOne option is to buy a Raspberry Pi starter kit from \nCanakit\n. These kits include most of the parts needed to get a fully working Raspberry Pi.\n\n\nThe number of IR LEDs is not critical. This will depend on how far away your subject is from the camera. Usually 4 IR LEDs is a good starting point.\n\n\nBuilding the system\n\n\nConfiguring a Raspberry Pi\n\n\nWe are not going to provide a full tutorial here and will assume a functioning Raspberry Pi. Here is a basic to do list to get started.\n\n\n\n\nInstall Raspbian on an SD card and boot the pi\n\n\nConfigure wired network\n\n\nMake sure the camera is installed\n\n\nInstall the \niPython\n command line interface\n\n\nInstall required python libraries\n\n\nMount a USB drive at boot\n\n\nSMB to mount/share folders with Windows computers\n\n\nAFP to mount/share folders with OS X (SMB will also work with OS X)\n\n\nStartUpMailer to have the Raspberry Pi email with its IP address when it boots\n\n\n\n\nChoosing the triggers\n\n\nThere are two different trigger options. These are set in the \nconfig.ini\n file using \nuseTwoTriggerPins\n\n\n\n\nTwo trigger pins, one for triggering start/stop of video and a second for triggering frames. This is the preferred triggering system. This is used to interface with a \nBruker\n microscope.\n\n\nOne trigger pin for both trigger and frames. This is used to interface with a microscope running \nScanImage\n software.\n\n\n\n\nWiring the system\n\n\n\n\nConnect camera to Raspberry Pi\n\n\nConnect signal and ground of GPIO/TTL cables from other equipment to the Raspberry Pi (be sure to convert incoming 5V GPIO to 3.5V)\n\n\nConnect IR LEDs to the Raspberry Pi. If LEDs need a lot of power, hook them up with a 5V relay and an external 12V power supply. See \nthis tutorial\n to wire a 5V LED to the Raspberry Pi.\n\n\n\n\n**Important:**\n The Raspberry Pi can only accept GPIO signals at 3.5V. Many devices use 5V for GPIO/TTL signals. Thus, a level shifter is needed to convert 5V to 3.5V. It is easy to make a \nvoltage divider\n by hand or to buy a pre-made \nvoltage level shifter\n.\n\n\n\n\nInstall required software\n\n\nClone github repository\n\n\nThis will download all the neccessary code into a directory named 'triggercamera'\n\n\ngit clone https://github.com/cudmore/triggercamera.git\n\n\n\nRun install script\n\n\nWe provide a ./install.sh script to install all required libraries. If this script fails, try installing manually.\n\n\ncd triggercamera\n./install.sh\n\n\n\nInstalling required Python libraries (manual)\n\n\nInstall libraries with apt-get\n\n\nsudo apt-get install python-dev #python development headers\nsudo apt-get install python-eventlet\nsudo apt-get install python-pandas\nsudo pip install plotly\n\n\n\nThe remaining libraries can be installed with pip.\n\n\npip install pyserial\npip install RPi.GPIO\npip install picamera\npip install ConfigParser\n\npip install flask\npip install flask-socketio\n\npip install platformio #to upload code to arduino\n\n\n\nArduino\n\n\nOptional Arduino code is provided in \ntriggercamera/arduino\n. This code uses an Arduino as a 'pass through' device, receiving 5V TTL pulses and passing them along to the Raspberry Pi at 3.5V (assuming an Arduino Teensy). The Arduino code will also \nsimulate a microscope\n, sending GPIO triggers for 'trial' and 'frame'.\n\n\nWe strongly suggest using an Arduino \nTeensy\n. The Teensy is (i) fast, (ii) has lots of memory, (iii) accepts 5V GPIO and outputs 3.5V, and (iv) all GPIO pins can be assigned as low level interrupts.\n\n\nPlatformIO is a command line interface to compile and upload code to an Arduino. It is easy to run at the command prompt on a Raspberry Pi. See \nthis blog post\n on installing and configuring PlatformIO.\n\n\nOnce PlatformIO is installed and configured to talk to an Arduino, upload code to an Arduino using\n\n\ncd triggercamera/arduino/bExperiment\nplatformio run --target upload\n\n\n\nThe correct serial port needs to be specified in \nconfig.ini\n. Find the Arduinos serial port by looking for something like ttyACM0 in\n\n\nls /dev/tty*\n\n\n\nRunning the camera\n\n\nLive video output\n\n\nThe primary interface for controlling the camera is through the Python command prompt or a web browser. An added feature is a real-time video can be viewed on an external video monitor. This is as simple as connecting the RCA plug on the Raspberry Pi to an external video monitor (not a computer monitor). Using this live video feed does not interfere with any of the Python or web browser code that interacts with the camera to trigger and save video.\n\n\nNOTE:\n The Raspberry Pi 2/3 uses a 3.5mm audio plug for both audio and composite video out. See \nhere\n.\n\n\nPython command line\n\n\nThe \niPython\n command line interface should be used.\n\n\nWith \ntriggercamera.py\n, the camera can be controlled with a Python command line. Once the camera is armed with 'startArm()', it will start and stop video recording following GPIO triggers.\n\n\nimport triggercamera\ntc = triggercamera.TriggerCamera()\ntc.startArm() #arm the camer to respond to triggers\n\ntc.stopArm() #stop the camera from responding to trigger\n\n\n\nAdditional interface\n\n\n#start and stop video recording as much as you like\ntc.startVideo()\ntc.stopVideo()\n\n# single images can be saved every few seconds while video is being recorded\ntc.doTimelapse=1\ntc.doTimelapse=0\n\n# todo: add interface to control two different LEDs\n\n\n\nWeb interface\n\n\ntriggercamera_app.py\n provides a web server allowing the camera to be controlled through a web browser.\n\n\nRun the web server with\n\n\npython triggercamera_app.py\n\n\n\nThen, bring up the web page from a browser (we suggest Chrome) using the IP address of the Raspberry and port 5010\n\n\nhttp://192.168.1.60:5010\n\n\n\nAdditional documentation on using this web interface is in the \nweb help\n page.\n\n\nStreaming video in the web interface\n\n\nOptionally, real-time video can be streamed from the camera to the web interface. This requires \nuv4l\n to be installed. See \nthis blog post\n to install uv4l on a Raspberry Pi.\n\n\nREST Interface\n\n\nIn addition to the point and click web interface, the web server provides a \nREST\n interface that can be remotely scripted using a set of web addresses.\n\n\nhttp://192.168.1.12:5010/startarm\nhttp://192.168.1.12:5010/stoparm\nhttp://192.168.1.12:5010/startvideo\nhttp://192.168.1.12:5010/stopvideo\nhttp://192.168.1.12:5010/timelapseon\nhttp://192.168.1.12:5010/timelapseoff\nhttp://192.168.1.12:5010/lastimage\n\n\n\nClient side code\n\n\nThe web server is running in Python on the raspberry Pi. When a web page is served to a client, the interface is provided using a large collection of client-side code written in \nJavaScript\n.\n\n\n\n\nSocket-io\n allows the Flask server to push updates to web-page without reloading the page\n\n\nBootstrap\n for page layout, buttons, sliders, value display\n\n\njquery\n to handle logic of user interface\n\n\nplotly.js\n to plot the arduino stimulus\n\n\nhighcharts.js\n to plot a trial in real-time while it is running (only used in treadmilll)\n\n\njqgrid\n to display a table of trials from disk\n\n\n\n\n\n\n\nUser configuration\n\n\nModify \nconfig.ini\n and restart the camera code\n\n\n[serial]\nuseSerial: True\nport: /dev/ttyACM0\nbaud: 9600\n\n[system]\nsavepath: /video\n\nwatchedpathon: False\nwatchedpath: ''\n\n[triggers]\nuseTwoTriggerPins: 1\ntriggerpin: 27\nframepin: 17\n\n[led]\nledpin1: 2\nledpin2: 3\n\n[camera]\nfps: 30\nresolution: 640,480\nbufferSeconds = 5\n\n[simulatescope]\non: 1\ninitialDelay: 1\nframeInterval: 30\nframeNumber: 300\n\n\n\nOutput video\n\n\nVideo is saved in the \nh264\n video format. This is a very efficient video codec that make very small but highly detailed videos. Before these h264 video files can be analyzed, they need to be converted to include the frames per second. This can be done in a number of video editing programs. One way to do this conversion is by using the command line program \nffmpeg\n. Because ffmpeg can be scripted, it is easy to incorporated into most workflows. The status of ffmpeg on the Pi is confusing. Here, we use a fork (or a nasty illegal fork?) called avconv.\n\n\nInstall avconv\n\n\nsudo apt-get install libav-tools\n\n\n\nConvert one .h264 file\n\n\navconv -r 30 -i 20160604_181119_after.h264 -vcodec copy 20160604_181119_after.mp4\n\n\n\nPseudocode to convert a directory of .h264 files\n\n\nsrcDir = '/src/dir/with/video/'\ndstDir = 'dst/dir/for/mp4/'\nfor file in srcDir:\n    outfile = file.strip('.h264') + '.mp4'\n    avconv -r 25 -i file -vcodec copy dstDir+outfile\n\n\n\nOutput files\n\n\nEach time the camera is triggered to save video, a .txt file with frame times is also saved.\n\n\nHere are the first 5 frames of an output .txt file. The first line is a header, second line gives column names, third line is start of data.\n\n\ndate=20160606,time=223717,trial=1,fps=30,width=640,height=480,numFrames=1799,ardFrames=0\ndate,time,seconds,event,frameNumber\n20160606,223623,1465266983.09,startVideo,\n20160606,223623,1465266983.12,numFrames,1\n20160606,223623,1465266983.15,numFrames,2\n20160606,223623,1465266983.18,numFrames,3\n20160606,223623,1465266983.21,numFrames,4\n20160606,223623,1465266983.24,numFrames,5\n\n\n\n\n\nAnalysis\n\n\nAnalyzing output .txt files\n\n\nWe have provided Python code to load, analyze and plot the output .txt files. See \nan example iPython notebook\n. Because the Raspberry Pi is not configured with a keyboard/mouse/monitor, this code can be run on a different machine using an iPython notebook.\n\n\nBring up an iPython web interface\n\n\n# if your Raspberry Pi is on the network at 'pi60'\ncd /Volumes/pi60/triggercamera/analysis/\nipython notebook\n\n\n\nHere is an analysis of the frame interval detected by the Raspberry Pi and a good example of some of the limitations. Using \n/arduino/bExperiment/src/bExperiment.cpp\n an Arduino output a frame pulse every 30 ms.\n\n\nIn general, the Raspberry Pi does not miss frames but  can occasionally detect frames late. The performance of the Pi can be degraded if additional software is run on the Pi. In general, keep it minimal.\n\n\n\n\nAnalyzing video\n\n\nWe will provide Python code using \nOpenCV\n to load and browse video files.\n\n\nAdd ons\n\n\nBy creating a system with a Raspberry Pi there are a large number of ways to quickly and cheaply extend the system in very useful ways.\n\n\n\n\n[Done] Add an Arduino microcontroller\n\n\nAdd an LCD/button controller\n\n\nAdd a touch-screen interface\n\n\n\n\nTroubleshooting\n\n\n\n\n\n\nTest the camera with\n\n\nraspistill -o tst.jpg\n\n\n\n\n\n\nIf the camera triggering is erratic or the Raspberry is missing fast pulses, check that all digital lines going to the Raspberry Pi are grounded. It is good practice to connect the Raspberry Pi ground pins to the ground (shield) of any digital lines.\n\n\n\n\n\n\nIf the recorded video changes light-levels erratically, this is usllay due to fluctuations in the power to the Pi. Make sure the Pi has a DC power supply \n2 Amps. If additional LEDs are being powered by the Pi, consider breaking these out with their own dedicated power supplies.\n\n\n\n\n\n\nSee \nthis\n to auto mount an SMB share on boot\n\n\n\n\n\n\nTo Do\n\n\n\n\nLook at controlling the camera with RPi_Cam_Web_Interface\n\n\nAdd basic camera controls for setting brightness. contrast, etc. etc.\n\n\nDone:\n Implement a Flask homepage to provide buttons to control camera and feedback during a trial.\n\n\nDone:\n Add control and interface for two LEDs (e.g. IR and white).\n\n\nDone:\n Add a header to output files #fps=xxx;width=xxx;height=xxx\n\n\nWrite a Python script to batch process a folder of .h264 into .mp4 (with fps)\n\n\nWrite a python video browser using Open-CV.\n\n\nWill not do this:\n try using easydict so i can use'.' notation in code\n\n\nAdd a physical emergency 'stop' button", 
            "title": "home"
        }, 
        {
            "location": "/#trigger-camera", 
            "text": "This is documentation to construct a system with a Raspberry Pi computer that responds to general purpose digital input-output (GPIO) pulses to start and stop video acquisition during an experiment. External events such as frame times on a scanning microscope are watermarked on the video and saved to a text file. The camera can be controlled from a Python command prompt or with a web browser.    Figure 1. Web-browser interface.  Example web interface for the Trigger Camera. See  web help  for more information", 
            "title": "Trigger Camera"
        }, 
        {
            "location": "/#overview", 
            "text": "This Raspberry Pi Trigger Camera camera is designed to integrate into our  Treadmill  system. The Treadmill system is advantageous if an Arduino is needed to precisely control other pieces of equipment like LEDs, motors, or valves.", 
            "title": "Overview"
        }, 
        {
            "location": "/#the-raspberry-pi", 
            "text": "The Raspberry Pi is a low cost ($35) computer that runs Linux. In addition to USB, ethernet, and HDMI connectors, the Raspberry Pi has a dedicated camera port and GPIO ports. Both the camera and GPIO ports can be easily programmed using Python. The Raspberry Pi provides an end-to-end open source system. Both the hardware and the software is provided by  The Raspberry Pi Foundation  and is actively maintained and extended by an active developer community.", 
            "title": "The Raspberry Pi"
        }, 
        {
            "location": "/#software-implementation", 
            "text": "The software provided here will run a Raspberry Pi camera as a slave to other devices already in place for an experiment. Once the camera is armed, it will continuously record a circular stream of video in memory. When a digital trigger is received, the video will begin being saved to disk. In addition to saving the video after a trigger, the video before the trigger will also be saved. This has the distinct advantage of given you a record of what your animal was doing  before a trial was started. In many cases, 'bad trials' can be found because there was a lot of movement (or some other abberent event) before a trial began.", 
            "title": "Software implementation"
        }, 
        {
            "location": "/#video-resolutions-and-fps", 
            "text": "The Raspberry Pi camera has the following resolutions and FPS. Set the resolution and FPS in the  config.ini  file. See the  PiCamera Python documentation  for more information.      Resolution  Aspect Ratio  Framerates  Video  Image  FoV  Binning      1  1920x1080  16:9  1-30fps  x   Partial  None    2  2592x1944  4:3  1-15fps  x  x  Full  None    3  2592x1944  4:3  0.1666-1fps  x  x  Full  None    4  1296x972  4:3  1-42fps  x   Full  2x2    5  1296x730  16:9  1-49fps  x   Full  2x2    6  640x480  4:3  42.1-60fps  x   Full  4x4    7  640x480  4:3  60.1-90fps  x   Full  4x4", 
            "title": "Video resolutions and FPS"
        }, 
        {
            "location": "/#limitations", 
            "text": "The Raspberry Pi runs Linux and like other operating systems including Microsoft Windows and Mac OS it is not real time. There will always be unpredictable delays in the detection and generation of GPIO pulses. If the detection of a fast pulse or the timing of a pulse is critical for an experiment it is strongly suggested to use a more precise microcontroller like an Arduino.  The Raspberry Pi camera is not a high-end camera. It records compressed video files, it does not record single frames to a video file. If you require a camera that captures individual frames, you should buy a high-end camera.    Saved video files are compressed with .h264  Saved video files are split into two files (we will wrote code to combine them after a trial)  Some frames will be late  Some frames may be missed  It is difficult to predict which frames will be late and/or missed   See the  Analysis  section for example Python code to test the limits of this precision.", 
            "title": "Limitations"
        }, 
        {
            "location": "/#parts-list", 
            "text": "The total cost should be about $150. These parts are widely available at many different online sellers including: Sparkfun, Adafruit, Element14, and Amazon.     Quatity  Item  Note  Cost  Link      1  Raspberry Pi 2 or 3  Either 2 or 3 is fine  $35-$40  element14 adafruit    1  Class 10 micro SD card  For the Rasperry system, 16 GB is fine  $10  link    1  5V 2A AC to DC power  Make sure it is  2A and don't buy a cheap one  $6-$8  link    1  Pi NoIR Camera   $25-$30  link    1  Pi Camera Ribbon cable (2 meters)   $6  link    1  Pi Camera HDMI extension cable  Optional  $15  link    1  USB Memory  To save video, 32GB or 64GB is a good starting point  $10-$15  link    1  Voltage level shifter  To convert 5V GPIO to 3.5V  $4  link    4  IR LEDS  900nm is best  $0.95  850nm / 950nm    4  Resistors  One for each IR LED  $7 (for 500 pack)  link    1  5V relay  To turn higher voltages like 12V on and off  $3  link     One option is to buy a Raspberry Pi starter kit from  Canakit . These kits include most of the parts needed to get a fully working Raspberry Pi.  The number of IR LEDs is not critical. This will depend on how far away your subject is from the camera. Usually 4 IR LEDs is a good starting point.", 
            "title": "Parts list"
        }, 
        {
            "location": "/#building-the-system", 
            "text": "", 
            "title": "Building the system"
        }, 
        {
            "location": "/#configuring-a-raspberry-pi", 
            "text": "We are not going to provide a full tutorial here and will assume a functioning Raspberry Pi. Here is a basic to do list to get started.   Install Raspbian on an SD card and boot the pi  Configure wired network  Make sure the camera is installed  Install the  iPython  command line interface  Install required python libraries  Mount a USB drive at boot  SMB to mount/share folders with Windows computers  AFP to mount/share folders with OS X (SMB will also work with OS X)  StartUpMailer to have the Raspberry Pi email with its IP address when it boots", 
            "title": "Configuring a Raspberry Pi"
        }, 
        {
            "location": "/#choosing-the-triggers", 
            "text": "There are two different trigger options. These are set in the  config.ini  file using  useTwoTriggerPins   Two trigger pins, one for triggering start/stop of video and a second for triggering frames. This is the preferred triggering system. This is used to interface with a  Bruker  microscope.  One trigger pin for both trigger and frames. This is used to interface with a microscope running  ScanImage  software.", 
            "title": "Choosing the triggers"
        }, 
        {
            "location": "/#wiring-the-system", 
            "text": "Connect camera to Raspberry Pi  Connect signal and ground of GPIO/TTL cables from other equipment to the Raspberry Pi (be sure to convert incoming 5V GPIO to 3.5V)  Connect IR LEDs to the Raspberry Pi. If LEDs need a lot of power, hook them up with a 5V relay and an external 12V power supply. See  this tutorial  to wire a 5V LED to the Raspberry Pi.   **Important:**  The Raspberry Pi can only accept GPIO signals at 3.5V. Many devices use 5V for GPIO/TTL signals. Thus, a level shifter is needed to convert 5V to 3.5V. It is easy to make a  voltage divider  by hand or to buy a pre-made  voltage level shifter .", 
            "title": "Wiring the system"
        }, 
        {
            "location": "/#install-required-software", 
            "text": "", 
            "title": "Install required software"
        }, 
        {
            "location": "/#clone-github-repository", 
            "text": "This will download all the neccessary code into a directory named 'triggercamera'  git clone https://github.com/cudmore/triggercamera.git", 
            "title": "Clone github repository"
        }, 
        {
            "location": "/#run-install-script", 
            "text": "We provide a ./install.sh script to install all required libraries. If this script fails, try installing manually.  cd triggercamera\n./install.sh", 
            "title": "Run install script"
        }, 
        {
            "location": "/#installing-required-python-libraries-manual", 
            "text": "Install libraries with apt-get  sudo apt-get install python-dev #python development headers\nsudo apt-get install python-eventlet\nsudo apt-get install python-pandas\nsudo pip install plotly  The remaining libraries can be installed with pip.  pip install pyserial\npip install RPi.GPIO\npip install picamera\npip install ConfigParser\n\npip install flask\npip install flask-socketio\n\npip install platformio #to upload code to arduino", 
            "title": "Installing required Python libraries (manual)"
        }, 
        {
            "location": "/#arduino", 
            "text": "Optional Arduino code is provided in  triggercamera/arduino . This code uses an Arduino as a 'pass through' device, receiving 5V TTL pulses and passing them along to the Raspberry Pi at 3.5V (assuming an Arduino Teensy). The Arduino code will also  simulate a microscope , sending GPIO triggers for 'trial' and 'frame'.  We strongly suggest using an Arduino  Teensy . The Teensy is (i) fast, (ii) has lots of memory, (iii) accepts 5V GPIO and outputs 3.5V, and (iv) all GPIO pins can be assigned as low level interrupts.  PlatformIO is a command line interface to compile and upload code to an Arduino. It is easy to run at the command prompt on a Raspberry Pi. See  this blog post  on installing and configuring PlatformIO.  Once PlatformIO is installed and configured to talk to an Arduino, upload code to an Arduino using  cd triggercamera/arduino/bExperiment\nplatformio run --target upload  The correct serial port needs to be specified in  config.ini . Find the Arduinos serial port by looking for something like ttyACM0 in  ls /dev/tty*", 
            "title": "Arduino"
        }, 
        {
            "location": "/#running-the-camera", 
            "text": "", 
            "title": "Running the camera"
        }, 
        {
            "location": "/#live-video-output", 
            "text": "The primary interface for controlling the camera is through the Python command prompt or a web browser. An added feature is a real-time video can be viewed on an external video monitor. This is as simple as connecting the RCA plug on the Raspberry Pi to an external video monitor (not a computer monitor). Using this live video feed does not interfere with any of the Python or web browser code that interacts with the camera to trigger and save video.  NOTE:  The Raspberry Pi 2/3 uses a 3.5mm audio plug for both audio and composite video out. See  here .", 
            "title": "Live video output"
        }, 
        {
            "location": "/#python-command-line", 
            "text": "The  iPython  command line interface should be used.  With  triggercamera.py , the camera can be controlled with a Python command line. Once the camera is armed with 'startArm()', it will start and stop video recording following GPIO triggers.  import triggercamera\ntc = triggercamera.TriggerCamera()\ntc.startArm() #arm the camer to respond to triggers\n\ntc.stopArm() #stop the camera from responding to trigger  Additional interface  #start and stop video recording as much as you like\ntc.startVideo()\ntc.stopVideo()\n\n# single images can be saved every few seconds while video is being recorded\ntc.doTimelapse=1\ntc.doTimelapse=0\n\n# todo: add interface to control two different LEDs", 
            "title": "Python command line"
        }, 
        {
            "location": "/#web-interface", 
            "text": "triggercamera_app.py  provides a web server allowing the camera to be controlled through a web browser.  Run the web server with  python triggercamera_app.py  Then, bring up the web page from a browser (we suggest Chrome) using the IP address of the Raspberry and port 5010  http://192.168.1.60:5010  Additional documentation on using this web interface is in the  web help  page.", 
            "title": "Web interface"
        }, 
        {
            "location": "/#streaming-video-in-the-web-interface", 
            "text": "Optionally, real-time video can be streamed from the camera to the web interface. This requires  uv4l  to be installed. See  this blog post  to install uv4l on a Raspberry Pi.", 
            "title": "Streaming video in the web interface"
        }, 
        {
            "location": "/#rest-interface", 
            "text": "In addition to the point and click web interface, the web server provides a  REST  interface that can be remotely scripted using a set of web addresses.  http://192.168.1.12:5010/startarm\nhttp://192.168.1.12:5010/stoparm\nhttp://192.168.1.12:5010/startvideo\nhttp://192.168.1.12:5010/stopvideo\nhttp://192.168.1.12:5010/timelapseon\nhttp://192.168.1.12:5010/timelapseoff\nhttp://192.168.1.12:5010/lastimage", 
            "title": "REST Interface"
        }, 
        {
            "location": "/#client-side-code", 
            "text": "The web server is running in Python on the raspberry Pi. When a web page is served to a client, the interface is provided using a large collection of client-side code written in  JavaScript .   Socket-io  allows the Flask server to push updates to web-page without reloading the page  Bootstrap  for page layout, buttons, sliders, value display  jquery  to handle logic of user interface  plotly.js  to plot the arduino stimulus  highcharts.js  to plot a trial in real-time while it is running (only used in treadmilll)  jqgrid  to display a table of trials from disk", 
            "title": "Client side code"
        }, 
        {
            "location": "/#user-configuration", 
            "text": "Modify  config.ini  and restart the camera code  [serial]\nuseSerial: True\nport: /dev/ttyACM0\nbaud: 9600\n\n[system]\nsavepath: /video\n\nwatchedpathon: False\nwatchedpath: ''\n\n[triggers]\nuseTwoTriggerPins: 1\ntriggerpin: 27\nframepin: 17\n\n[led]\nledpin1: 2\nledpin2: 3\n\n[camera]\nfps: 30\nresolution: 640,480\nbufferSeconds = 5\n\n[simulatescope]\non: 1\ninitialDelay: 1\nframeInterval: 30\nframeNumber: 300", 
            "title": "User configuration"
        }, 
        {
            "location": "/#output-video", 
            "text": "Video is saved in the  h264  video format. This is a very efficient video codec that make very small but highly detailed videos. Before these h264 video files can be analyzed, they need to be converted to include the frames per second. This can be done in a number of video editing programs. One way to do this conversion is by using the command line program  ffmpeg . Because ffmpeg can be scripted, it is easy to incorporated into most workflows. The status of ffmpeg on the Pi is confusing. Here, we use a fork (or a nasty illegal fork?) called avconv.  Install avconv  sudo apt-get install libav-tools  Convert one .h264 file  avconv -r 30 -i 20160604_181119_after.h264 -vcodec copy 20160604_181119_after.mp4  Pseudocode to convert a directory of .h264 files  srcDir = '/src/dir/with/video/'\ndstDir = 'dst/dir/for/mp4/'\nfor file in srcDir:\n    outfile = file.strip('.h264') + '.mp4'\n    avconv -r 25 -i file -vcodec copy dstDir+outfile", 
            "title": "Output video"
        }, 
        {
            "location": "/#output-files", 
            "text": "Each time the camera is triggered to save video, a .txt file with frame times is also saved.  Here are the first 5 frames of an output .txt file. The first line is a header, second line gives column names, third line is start of data.  date=20160606,time=223717,trial=1,fps=30,width=640,height=480,numFrames=1799,ardFrames=0\ndate,time,seconds,event,frameNumber\n20160606,223623,1465266983.09,startVideo,\n20160606,223623,1465266983.12,numFrames,1\n20160606,223623,1465266983.15,numFrames,2\n20160606,223623,1465266983.18,numFrames,3\n20160606,223623,1465266983.21,numFrames,4\n20160606,223623,1465266983.24,numFrames,5", 
            "title": "Output files"
        }, 
        {
            "location": "/#analysis", 
            "text": "", 
            "title": "Analysis"
        }, 
        {
            "location": "/#analyzing-output-txt-files", 
            "text": "We have provided Python code to load, analyze and plot the output .txt files. See  an example iPython notebook . Because the Raspberry Pi is not configured with a keyboard/mouse/monitor, this code can be run on a different machine using an iPython notebook.  Bring up an iPython web interface  # if your Raspberry Pi is on the network at 'pi60'\ncd /Volumes/pi60/triggercamera/analysis/\nipython notebook  Here is an analysis of the frame interval detected by the Raspberry Pi and a good example of some of the limitations. Using  /arduino/bExperiment/src/bExperiment.cpp  an Arduino output a frame pulse every 30 ms.  In general, the Raspberry Pi does not miss frames but  can occasionally detect frames late. The performance of the Pi can be degraded if additional software is run on the Pi. In general, keep it minimal.", 
            "title": "Analyzing output .txt files"
        }, 
        {
            "location": "/#analyzing-video", 
            "text": "We will provide Python code using  OpenCV  to load and browse video files.", 
            "title": "Analyzing video"
        }, 
        {
            "location": "/#add-ons", 
            "text": "By creating a system with a Raspberry Pi there are a large number of ways to quickly and cheaply extend the system in very useful ways.   [Done] Add an Arduino microcontroller  Add an LCD/button controller  Add a touch-screen interface", 
            "title": "Add ons"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "Test the camera with  raspistill -o tst.jpg    If the camera triggering is erratic or the Raspberry is missing fast pulses, check that all digital lines going to the Raspberry Pi are grounded. It is good practice to connect the Raspberry Pi ground pins to the ground (shield) of any digital lines.    If the recorded video changes light-levels erratically, this is usllay due to fluctuations in the power to the Pi. Make sure the Pi has a DC power supply  2 Amps. If additional LEDs are being powered by the Pi, consider breaking these out with their own dedicated power supplies.    See  this  to auto mount an SMB share on boot", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/#to-do", 
            "text": "Look at controlling the camera with RPi_Cam_Web_Interface  Add basic camera controls for setting brightness. contrast, etc. etc.  Done:  Implement a Flask homepage to provide buttons to control camera and feedback during a trial.  Done:  Add control and interface for two LEDs (e.g. IR and white).  Done:  Add a header to output files #fps=xxx;width=xxx;height=xxx  Write a Python script to batch process a folder of .h264 into .mp4 (with fps)  Write a python video browser using Open-CV.  Will not do this:  try using easydict so i can use'.' notation in code  Add a physical emergency 'stop' button", 
            "title": "To Do"
        }, 
        {
            "location": "/dev/", 
            "text": "PlatformIO\n\n\nsudo pip install platformio #one time install\n\nplatformio init --board teensy31\n\nplatformio run --target upload\n\nplatformio run --target clean\n\nplatformio serialports monitor -p /dev/ttyACM0 -b 115200 #a serial port monitor\n\n\n\nmkDocs\n\n\npip install mkdocs\npip install mkdocs-cinder\n\nmkdocs serve\nmkdocs serve --dev-addr=0.0.0.0:8000 # serves built site on LAN IP\n\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nDeploy to github\n\n\nmkdocs gh-deploy will use the gh-pages branch of repository specified in mkdocs.yml\n\n\n# this will deploy to github gh-pages specified in mkdocs.yml\ncd tiggercamera #should have mkdocs.yml file\nmkdocs build --clean\nmkdocs gh-deploy --clean \n#site is then available at\nhttp://cudmore.github.io/triggercamera\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n\n\n\nInstall Raspbian\n\n\nIf you are Microsoft Windows based, have a look \nhere\n for a good install guide.\n\n\nDownload image\n\n\nAs of May 21, 2016 the image was named \n2016-05-10-raspbian-jessie\n. \nDownload here\n\n\nCopy image to SD card\n\n\nFollow an installation guide \nhere\n.\n\n\nOn Mac OS\n\n\n#Insert SD card and format as Fat32\ndiskutil list # find the /dev/disk\nn\n, mine was /dev/disk3\ndiskutil unmountDisk /dev/disk3 #unmount disk\n# copy .img file to disk\nsudo dd bs=1m if=/Users/cudmore/Downloads/2016-05-10-raspbian-jessie.img of=/dev/rdisk3\n\n\n\nFirst boot of the Pi\n\n\nConnect Pi to a router with an ethernet cable and boot\n\n\nFind IP address using router web interface, usually http://192.168.1.1\n\n\nLogin via ssh\n\n\nssh pi@192.168.1.15\n#password is raspberry\n\n\n\nRun configuration utility\n\n\nsudo raspi-config\n\n\n\n\n\n1 Expand Filesystem\n\n\n2 Change User Password\n\n\n3 Boot Options\n\n\nB1 Console\n\n\n\n\n\n\n5 Internationalisation Options\n\n\nI1 Change Local -\n en_US.UTF-8 UTF-8\n\n\nI2 Change Timezone -\n US -\n Eastern\n\n\nI4 Change Wi-fi Country -\n US United States\n\n\n\n\n\n\n6 Enable Camera\n\n\n9 Advanced Options\n\n\nA2 Hostname -\n [choose a name here, I chose pi3]\n\n\n\n\n\n\n\n\nSelecting \n3 Boot Options -\n Console\n is important. It seems Raspbian ships with X-Windows on by default.\n\n\nUpdate the system\n\n\nsudo apt-get update  #update database\nsudo apt-get upgrade #update userspace\nsudo rpi-update      #update firmware (requires reboot)\nsudo reboot          #reboot\n\n\n\nApple File Protocol with open-source netatalk\n\n\nOnce netatalk is installed, the Raspberry will show up in the Mac Finder 'Shared' section\n\n\nsudo apt-get install netatalk\n\n\n\nMake the Pi send email with IP on boot\n\n\nCreate an executable python script to send en email with IP. An example \nstartup_mailer.py\n\n\nmkdir code\ncd code\nwget https://github.com/cudmore/cudmore.github.io/raw/master/_site/downloads/startup_mailer.py\nchmod +x startup_mailer.py\n\n\n\nMake sure the first line in the .py code is \n#!/usr/bin/python\n.\n\n\n#!/usr/bin/python\n\n\n\nSet the email parameters in startup_mail.py\n\n\nto = 'robert.cudmore@gmail.com'\ngmail_user = 'cudmore.raspberry@gmail.com'\ngmail_password = 'ENTER_YOUR_PASSWORD_HERE'\n\n\n\nRun crontab as root and append one line \n@reboot (sleep 10; /home/pi/code/startup_mailer.py)\n\n\nsudo crontab -e\n\n\n\nAdd this to end (sleep 5 does not work!!!!)\n\n\n@reboot (sleep 10; /home/pi/code/startup_mailer.py)\n\n\n\nNow, when pi boots it will send an email with it's ip. Try it with\n\n\nsudo reboot", 
            "title": "dev"
        }, 
        {
            "location": "/dev/#platformio", 
            "text": "sudo pip install platformio #one time install\n\nplatformio init --board teensy31\n\nplatformio run --target upload\n\nplatformio run --target clean\n\nplatformio serialports monitor -p /dev/ttyACM0 -b 115200 #a serial port monitor", 
            "title": "PlatformIO"
        }, 
        {
            "location": "/dev/#mkdocs", 
            "text": "pip install mkdocs\npip install mkdocs-cinder\n\nmkdocs serve\nmkdocs serve --dev-addr=0.0.0.0:8000 # serves built site on LAN IP   mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "mkDocs"
        }, 
        {
            "location": "/dev/#deploy-to-github", 
            "text": "mkdocs gh-deploy will use the gh-pages branch of repository specified in mkdocs.yml  # this will deploy to github gh-pages specified in mkdocs.yml\ncd tiggercamera #should have mkdocs.yml file\nmkdocs build --clean\nmkdocs gh-deploy --clean \n#site is then available at\nhttp://cudmore.github.io/triggercamera", 
            "title": "Deploy to github"
        }, 
        {
            "location": "/dev/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/dev/#install-raspbian", 
            "text": "If you are Microsoft Windows based, have a look  here  for a good install guide.", 
            "title": "Install Raspbian"
        }, 
        {
            "location": "/dev/#download-image", 
            "text": "As of May 21, 2016 the image was named  2016-05-10-raspbian-jessie .  Download here", 
            "title": "Download image"
        }, 
        {
            "location": "/dev/#copy-image-to-sd-card", 
            "text": "Follow an installation guide  here .  On Mac OS  #Insert SD card and format as Fat32\ndiskutil list # find the /dev/disk n , mine was /dev/disk3\ndiskutil unmountDisk /dev/disk3 #unmount disk\n# copy .img file to disk\nsudo dd bs=1m if=/Users/cudmore/Downloads/2016-05-10-raspbian-jessie.img of=/dev/rdisk3", 
            "title": "Copy image to SD card"
        }, 
        {
            "location": "/dev/#first-boot-of-the-pi", 
            "text": "Connect Pi to a router with an ethernet cable and boot  Find IP address using router web interface, usually http://192.168.1.1", 
            "title": "First boot of the Pi"
        }, 
        {
            "location": "/dev/#login-via-ssh", 
            "text": "ssh pi@192.168.1.15\n#password is raspberry", 
            "title": "Login via ssh"
        }, 
        {
            "location": "/dev/#run-configuration-utility", 
            "text": "sudo raspi-config   1 Expand Filesystem  2 Change User Password  3 Boot Options  B1 Console    5 Internationalisation Options  I1 Change Local -  en_US.UTF-8 UTF-8  I2 Change Timezone -  US -  Eastern  I4 Change Wi-fi Country -  US United States    6 Enable Camera  9 Advanced Options  A2 Hostname -  [choose a name here, I chose pi3]     Selecting  3 Boot Options -  Console  is important. It seems Raspbian ships with X-Windows on by default.", 
            "title": "Run configuration utility"
        }, 
        {
            "location": "/dev/#update-the-system", 
            "text": "sudo apt-get update  #update database\nsudo apt-get upgrade #update userspace\nsudo rpi-update      #update firmware (requires reboot)\nsudo reboot          #reboot", 
            "title": "Update the system"
        }, 
        {
            "location": "/dev/#apple-file-protocol-with-open-source-netatalk", 
            "text": "Once netatalk is installed, the Raspberry will show up in the Mac Finder 'Shared' section  sudo apt-get install netatalk", 
            "title": "Apple File Protocol with open-source netatalk"
        }, 
        {
            "location": "/dev/#make-the-pi-send-email-with-ip-on-boot", 
            "text": "Create an executable python script to send en email with IP. An example  startup_mailer.py  mkdir code\ncd code\nwget https://github.com/cudmore/cudmore.github.io/raw/master/_site/downloads/startup_mailer.py\nchmod +x startup_mailer.py  Make sure the first line in the .py code is  #!/usr/bin/python .  #!/usr/bin/python  Set the email parameters in startup_mail.py  to = 'robert.cudmore@gmail.com'\ngmail_user = 'cudmore.raspberry@gmail.com'\ngmail_password = 'ENTER_YOUR_PASSWORD_HERE'  Run crontab as root and append one line  @reboot (sleep 10; /home/pi/code/startup_mailer.py)  sudo crontab -e  Add this to end (sleep 5 does not work!!!!)  @reboot (sleep 10; /home/pi/code/startup_mailer.py)  Now, when pi boots it will send an email with it's ip. Try it with  sudo reboot", 
            "title": "Make the Pi send email with IP on boot"
        }, 
        {
            "location": "/webhelp/", 
            "text": "Minimized\n\n\n\n\n\n\n\nThe top section of the interface provides feedback on the camera status. When a trial is running and video is being recorded, the spinner will spin and \nElapsed Time\n, \nFrame\n, \nTrial\n, and \nFile\n will update.\n\n\nUse the \nStart Arm\n and \nStop Arm\n buttons to turn the listening for a trigger on and off.\n\n\nUse the \nStart Stream\n and \nStop Stream\n buttons to turn real-time video streaming on and off.\n\n\nIf LEDs are wired to the Raspberry Pi, LED1 and LED2 provide an interface to turn them on and off as well as to set their brightness levels.\n\n\nMaximized\n\n\n\n\n\n\n\nWhen maximized, there are additional sections for analysis, options, and simulation of a microscope triggers.\n\n\nAnalysis\n\n\nThe \nPlot Last Trial\n button will generate a plot of frame-intervals versus frame number for the last trial. This can be used to verify that frame triggering is working as expected. In this example, the majority of 600 frames had an  interval of 30 ms with 4 bad frames.\n\n\nBring up the Analysis page (with the line graph icon) to make the same plot for any trials previously recorded.\n\n\nOptions\n\n\nDisplays the current camera and system configuration. This includes camera frames-per-second (fps) and image size. This also includes the GPIO pin numbers for trigger and frame.\n\n\nTo change options, manually edit the config.ini file and then 'REload Configuration'.\n\n\nSimulate\n\n\nIf configured, will use an Arduino to simulate trial and frame triggers of a microscope. This is useful for debugging the camera.\n\n\nAnalysis\n\n\nThe analysis web page displays a list of trials that have been acquired with the camera. Double-click on a trial (row) to display the timing of the frames.", 
            "title": "web help"
        }, 
        {
            "location": "/webhelp/#minimized", 
            "text": "The top section of the interface provides feedback on the camera status. When a trial is running and video is being recorded, the spinner will spin and  Elapsed Time ,  Frame ,  Trial , and  File  will update.  Use the  Start Arm  and  Stop Arm  buttons to turn the listening for a trigger on and off.  Use the  Start Stream  and  Stop Stream  buttons to turn real-time video streaming on and off.  If LEDs are wired to the Raspberry Pi, LED1 and LED2 provide an interface to turn them on and off as well as to set their brightness levels.", 
            "title": "Minimized"
        }, 
        {
            "location": "/webhelp/#maximized", 
            "text": "When maximized, there are additional sections for analysis, options, and simulation of a microscope triggers.", 
            "title": "Maximized"
        }, 
        {
            "location": "/webhelp/#analysis", 
            "text": "The  Plot Last Trial  button will generate a plot of frame-intervals versus frame number for the last trial. This can be used to verify that frame triggering is working as expected. In this example, the majority of 600 frames had an  interval of 30 ms with 4 bad frames.  Bring up the Analysis page (with the line graph icon) to make the same plot for any trials previously recorded.", 
            "title": "Analysis"
        }, 
        {
            "location": "/webhelp/#options", 
            "text": "Displays the current camera and system configuration. This includes camera frames-per-second (fps) and image size. This also includes the GPIO pin numbers for trigger and frame.  To change options, manually edit the config.ini file and then 'REload Configuration'.", 
            "title": "Options"
        }, 
        {
            "location": "/webhelp/#simulate", 
            "text": "If configured, will use an Arduino to simulate trial and frame triggers of a microscope. This is useful for debugging the camera.", 
            "title": "Simulate"
        }, 
        {
            "location": "/webhelp/#analysis_1", 
            "text": "The analysis web page displays a list of trials that have been acquired with the camera. Double-click on a trial (row) to display the timing of the frames.", 
            "title": "Analysis"
        }
    ]
}